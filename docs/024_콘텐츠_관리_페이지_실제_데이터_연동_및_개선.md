# 024. 콘텐츠 관리 페이지 실제 데이터 연동 및 개선

## 문서 정보
- **작성일**: 2025-10-31
- **관련 문서**:
  - [020_회원_관리_페이지_실제_데이터_연동_및_페이지네이션.md](./020_회원_관리_페이지_실제_데이터_연동_및_페이지네이션.md)
  - [DATABASE_SCHEMA.md](../DATABASE_SCHEMA.md)
- **참조 파일**:
  - `app/admin/users/page.tsx` (디자인 시스템 참조)
  - `app/admin/contents/page.tsx` (개선 대상)
  - `lib/api/users.ts` (API 패턴 참조)

## 1. 개요

### 1.1 목적
회원 관리 페이지와 동일한 디자인 시스템 및 데이터 조회 로직을 콘텐츠 관리 페이지에 적용하여 일관성 있는 관리자 경험 제공

### 1.2 주요 변경사항
- Mock 데이터 → 실제 Supabase 데이터 연동
- Zustand 선택 상태 → TanStack Table 로컬 상태로 변경
- AI 분석 기능 제거 (일괄 분석, 개별 분석 버튼)
- 검색 기능 확장: 파일명 → 파일명 + 업로더명 + 컬렉션명
- 페이지네이션 추가 (회원 관리와 동일한 방식)

## 2. 현재 상태 분석

### 2.1 기존 콘텐츠 페이지 문제점

#### 데이터 레이어
```typescript
// ❌ 문제: Mock 데이터 사용
const filteredContents = useMemo(() => {
  let result = [...mockContents]
  // 클라이언트 사이드 필터링
}, [contentFilters])
```

**문제점:**
- 실제 Supabase 데이터를 조회하지 않음
- 서버 사이드 페이지네이션 없음
- JOIN 데이터 없음 (user_name, collection_name)

#### 상태 관리
```typescript
// ❌ 문제: Zustand 전역 상태 사용
const { selectedContentIds, toggleContentSelection } = useAdminStore()
```

**문제점:**
- 회원 관리 페이지와 상태 관리 방식 불일치
- TanStack Table의 내장 선택 기능 미사용

#### UI/UX
```typescript
// ❌ 문제: AI 분석 버튼 존재
{content.is_analyzed === null && (
  <AnalysisButton contentId={content.id} onAnalyze={handleAnalyze} />
)}

// ❌ 문제: 일괄 분석 버튼
<Button onClick={() => onAnalyze?.(selectedIds)}>
  <Play className="h-4 w-4" />
  일괄 분석
</Button>
```

**요구사항:**
- AI 분석 관련 UI 모두 제거
- 일괄 삭제 버튼만 유지

#### 검색 기능
```typescript
// ❌ 문제: 파일명만 검색
<Input placeholder="파일명 검색..." />

// 필터링 로직
result = result.filter((content) =>
  content.file_name.toLowerCase().includes(searchLower)
)
```

**요구사항:**
- 파일명 + 업로더명 + 컬렉션명 검색

### 2.2 회원 관리 페이지 성공 패턴

#### 데이터 조회 패턴
```typescript
// ✅ 성공: 서버 사이드 데이터 조회
useEffect(() => {
  async function fetchData() {
    setLoading(true)
    const result = await getUsersWithPagination({
      page: userFilters.page,
      pageSize: 10,
      search: userFilters.search,
      is_approved: userFilters.is_approved,
      role: userFilters.role,
    })

    if (result.success && result.data) {
      setUsers(result.data)
      setTotalCount(result.totalCount)
    }
  }
  fetchData()
}, [userFilters, toast])
```

#### 테이블 상태 관리
```typescript
// ✅ 성공: TanStack Table 로컬 상태
const [rowSelection, setRowSelection] = useState({})

const table = useReactTable({
  data: users,
  columns,
  getCoreRowModel: getCoreRowModel(),
  manualPagination: true,
  state: { rowSelection },
  onRowSelectionChange: setRowSelection,
})

const selectedIds = table.getFilteredSelectedRowModel().rows.map(row => row.original.id)
```

#### 일괄 작업 UI
```typescript
// ✅ 성공: 항상 렌더링, disabled 상태로 제어
<div className="flex items-center justify-end gap-2">
  {selectedIds.length > 0 && (
    <span className="text-sm text-gray-500">{selectedIds.length} 선택됨</span>
  )}
  <Button
    disabled={selectedIds.length === 0}
    onClick={() => { /* action */ }}
  >
    일괄 승인
  </Button>
</div>
```

## 3. 데이터베이스 구조 분석

### 3.1 테이블 관계

```
users                    collections              contents                 detected_contents
┌─────────────┐         ┌─────────────┐         ┌─────────────┐         ┌──────────────────┐
│ id (PK)     │◄────┐   │ id (PK)     │◄────┐   │ id (PK)     │◄────────│ content_id (FK)  │
│ name        │     │   │ user_id(FK) │     │   │ user_id(FK) │         │ source_url       │
│ email       │     │   │ name        │     │   │ collection  │         │ image_url        │
│ organization│     │   │ created_at  │     │   │   _id (FK)  │         │ detection_type   │
│ role        │     └───┤             │     └───┤ file_name   │         │ admin_review     │
│ is_approved │         └─────────────┘         │ file_path   │         │   _status        │
│ created_at  │                                 │ is_analyzed │         │ created_at       │
└─────────────┘                                 │ created_at  │         └──────────────────┘
                                                └─────────────┘
```

### 3.2 필요한 JOIN 데이터

콘텐츠 관리 페이지에서 표시할 데이터:

```typescript
interface Content {
  // 기본 필드 (contents 테이블)
  id: string
  user_id: string
  collection_id: string | null
  file_name: string
  file_path: string
  is_analyzed: boolean | null
  message: string | null
  created_at: string

  // JOIN 데이터 (필요)
  user_name?: string              // users.name
  collection_name?: string        // collections.name
  detected_count?: number         // COUNT(detected_contents)
}
```

## 4. API 레이어 설계

### 4.1 신규 API 함수: `getContentsWithPagination`

**파일**: `lib/api/contents.ts` (기존 파일에 추가)

```typescript
interface GetContentsParams {
  page?: number
  pageSize?: number
  is_analyzed?: boolean | null
  search?: string
}

/**
 * 관리자용 콘텐츠 목록 조회 (페이지네이션, 검색, 필터링 포함)
 * JOIN: users, collections
 * COUNT: detected_contents
 *
 * @param params - 조회 파라미터
 * @returns PaginatedApiResponse<Content[]>
 */
export async function getContentsWithPagination(
  params: GetContentsParams = {}
): Promise<PaginatedApiResponse<Content[]>> {
  try {
    const { page = 1, pageSize = 10, is_analyzed, search } = params

    // 1. 기본 쿼리 (count: 'exact'로 전체 개수도 함께 조회)
    let query = supabase
      .from('contents')
      .select(`
        *,
        users!inner(name),
        collections(name)
      `, { count: 'exact' })

    // 2. is_analyzed 필터 적용
    if (is_analyzed === null) {
      // 대기: is_analyzed IS NULL
      query = query.is('is_analyzed', null)
    } else if (is_analyzed === true) {
      // 완료: is_analyzed = true
      query = query.eq('is_analyzed', true)
    } else if (is_analyzed === false) {
      // 분석 중: is_analyzed = false
      query = query.eq('is_analyzed', false)
    }
    // is_analyzed가 undefined이면 조건 추가 안 함 (전체)

    // 3. 검색 필터 적용 (파일명, 업로더명, 컬렉션명)
    if (search && search.trim() !== '') {
      const searchPattern = `%${search.trim()}%`
      query = query.or(
        `file_name.ilike.${searchPattern},users.name.ilike.${searchPattern},collections.name.ilike.${searchPattern}`
      )
    }

    // 4. 정렬: 최신순
    query = query.order('created_at', { ascending: false })

    // 5. 페이지네이션 적용
    const from = (page - 1) * pageSize
    const to = from + pageSize - 1
    query = query.range(from, to)

    const { data, error, count } = await query

    if (error) {
      console.error('콘텐츠 조회 중 오류:', error)
      return {
        data: null,
        totalCount: 0,
        error: error.message,
        success: false,
      }
    }

    // 6. detected_count 계산 (별도 쿼리 또는 후처리)
    // 옵션 A: 각 content마다 별도 쿼리 (N+1 문제 있지만 페이지당 10개만)
    // 옵션 B: RPC 함수로 한번에 조회 (더 효율적)

    const contentsWithCount = await Promise.all(
      (data || []).map(async (content: any) => {
        const { count: detectedCount } = await supabase
          .from('detected_contents')
          .select('*', { count: 'exact', head: true })
          .eq('content_id', content.id)

        return {
          ...content,
          user_name: content.users?.name,
          collection_name: content.collections?.name,
          detected_count: detectedCount || 0,
        }
      })
    )

    return {
      data: contentsWithCount as Content[],
      totalCount: count || 0,
      error: null,
      success: true,
    }
  } catch (error) {
    console.error('콘텐츠 조회 중 오류:', error)
    return {
      data: null,
      totalCount: 0,
      error: '콘텐츠를 불러오는 중 오류가 발생했습니다.',
      success: false,
    }
  }
}
```

### 4.2 일괄 삭제 API 함수

```typescript
/**
 * 콘텐츠 일괄 삭제
 * @param contentIds - 삭제할 콘텐츠 ID 배열
 * @returns ApiResponse<null>
 */
export async function bulkDeleteContents(
  contentIds: string[]
): Promise<ApiResponse<null>> {
  try {
    // 1. 각 콘텐츠의 file_path 조회
    const { data: contents, error: fetchError } = await supabase
      .from('contents')
      .select('id, file_path')
      .in('id', contentIds)

    if (fetchError) {
      return {
        data: null,
        error: fetchError.message,
        success: false,
      }
    }

    // 2. Storage에서 파일 삭제
    const filePaths = (contents || []).map((c: any) => {
      // file_path가 전체 URL인 경우 경로만 추출
      return c.file_path.includes('/')
        ? c.file_path.split('/').slice(-3).join('/')
        : c.file_path
    })

    if (filePaths.length > 0) {
      const { error: storageError } = await supabase.storage
        .from('contents')
        .remove(filePaths)

      if (storageError) {
        console.error('Storage 파일 삭제 실패:', storageError)
        // Storage 삭제 실패해도 DB는 삭제 진행
      }
    }

    // 3. DB에서 레코드 삭제 (detected_contents는 CASCADE로 자동 삭제)
    const { error: deleteError } = await supabase
      .from('contents')
      .delete()
      .in('id', contentIds)

    if (deleteError) {
      return {
        data: null,
        error: `콘텐츠 삭제 실패: ${deleteError.message}`,
        success: false,
      }
    }

    return {
      data: null,
      error: null,
      success: true,
    }
  } catch (error) {
    console.error('일괄 삭제 중 오류:', error)
    return {
      data: null,
      error: '일괄 삭제 중 오류가 발생했습니다.',
      success: false,
    }
  }
}
```

### 4.3 Supabase 쿼리 최적화 고려사항

#### detected_count 조회 최적화

**현재 방식 (N+1 문제):**
```typescript
// 각 content마다 별도 쿼리 실행
const contentsWithCount = await Promise.all(
  data.map(async (content) => {
    const { count } = await supabase
      .from('detected_contents')
      .select('*', { count: 'exact', head: true })
      .eq('content_id', content.id)
    return { ...content, detected_count: count }
  })
)
```

**최적화된 방식 (PostgreSQL Function):**

```sql
-- RPC 함수 생성
CREATE OR REPLACE FUNCTION get_contents_with_counts(
  p_page INT DEFAULT 1,
  p_page_size INT DEFAULT 10,
  p_is_analyzed BOOLEAN DEFAULT NULL,
  p_search TEXT DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  user_id UUID,
  collection_id UUID,
  file_name TEXT,
  file_path TEXT,
  is_analyzed BOOLEAN,
  message TEXT,
  created_at TIMESTAMPTZ,
  user_name TEXT,
  collection_name TEXT,
  detected_count BIGINT,
  total_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.user_id,
    c.collection_id,
    c.file_name,
    c.file_path,
    c.is_analyzed,
    c.message,
    c.created_at,
    u.name AS user_name,
    col.name AS collection_name,
    COUNT(dc.id) AS detected_count,
    COUNT(*) OVER() AS total_count
  FROM contents c
  INNER JOIN users u ON c.user_id = u.id
  LEFT JOIN collections col ON c.collection_id = col.id
  LEFT JOIN detected_contents dc ON c.id = dc.content_id
  WHERE
    (p_is_analyzed IS NULL OR c.is_analyzed = p_is_analyzed OR (p_is_analyzed IS NULL AND c.is_analyzed IS NULL))
    AND (p_search IS NULL OR c.file_name ILIKE '%' || p_search || '%' OR u.name ILIKE '%' || p_search || '%' OR col.name ILIKE '%' || p_search || '%')
  GROUP BY c.id, u.name, col.name
  ORDER BY c.created_at DESC
  LIMIT p_page_size OFFSET (p_page - 1) * p_page_size;
END;
$$ LANGUAGE plpgsql;
```

**호출:**
```typescript
const { data, error } = await supabase.rpc('get_contents_with_counts', {
  p_page: page,
  p_page_size: pageSize,
  p_is_analyzed: is_analyzed,
  p_search: search
})
```

**장점:**
- 단일 쿼리로 모든 데이터 조회
- N+1 문제 해결
- 데이터베이스 레벨 최적화

**결론:**
- 초기 구현은 N+1 방식 (간단함, 페이지당 10개만)
- 성능 문제 발생 시 RPC 함수로 마이그레이션

## 5. 컴포넌트 설계

### 5.1 ContentFilters 컴포넌트 개선

**파일**: `components/admin/contents/ContentFilters.tsx`

```typescript
'use client'

import { Search } from 'lucide-react'
import { Input } from '@/components/ui/input'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import { ContentFilters as ContentFiltersType } from '@/lib/admin/types'

interface ContentFiltersProps {
  filters: ContentFiltersType
  onFilterChange: (filters: ContentFiltersType) => void
}

export function ContentFilters({ filters, onFilterChange }: ContentFiltersProps) {
  const handleSearchChange = (value: string) => {
    onFilterChange({ ...filters, search: value || undefined, page: 1 })
  }

  const handleAnalysisStatusChange = (value: string) => {
    let isAnalyzed: boolean | null | undefined

    if (value === 'all') {
      isAnalyzed = undefined // 전체
    } else if (value === 'pending') {
      isAnalyzed = null // 대기
    } else if (value === 'analyzing') {
      isAnalyzed = false // 분석 중
    } else if (value === 'completed') {
      isAnalyzed = true // 완료
    }

    onFilterChange({
      ...filters,
      is_analyzed: isAnalyzed,
      page: 1, // 필터 변경 시 첫 페이지로
    })
  }

  // is_analyzed 값을 Select value로 변환
  const getAnalysisStatusValue = () => {
    if (filters.is_analyzed === undefined) return 'all'
    if (filters.is_analyzed === null) return 'pending'
    if (filters.is_analyzed === false) return 'analyzing'
    if (filters.is_analyzed === true) return 'completed'
    return 'all'
  }

  return (
    <div className="flex flex-wrap gap-4">
      {/* 검색 (파일명, 업로더명, 컬렉션명) */}
      <div className="relative min-w-[200px] flex-1">
        <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400" />
        <Input
          placeholder="파일명, 업로더, 컬렉션 검색..."
          value={filters.search || ''}
          onChange={(e) => handleSearchChange(e.target.value)}
          className="bg-white pl-10"
        />
      </div>

      {/* 분석 상태 필터 */}
      <Select
        value={getAnalysisStatusValue()}
        onValueChange={handleAnalysisStatusChange}
      >
        <SelectTrigger className="bg-white w-[150px]">
          <SelectValue placeholder="분석 상태" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="all">전체 상태</SelectItem>
          <SelectItem value="completed">완료</SelectItem>
          <SelectItem value="pending">대기</SelectItem>
          <SelectItem value="analyzing">분석 중</SelectItem>
        </SelectContent>
      </Select>
    </div>
  )
}
```

**변경사항:**
- `placeholder`: "파일명 검색..." → "파일명, 업로더, 컬렉션 검색..."
- `page` 상태 추가: 필터 변경 시 1페이지로 리셋
- `bg-white` 클래스 추가 (회원 관리 페이지와 일관성)

### 5.2 ContentTableClient 컴포넌트 신규 작성

**파일**: `components/admin/contents/ContentTableClient.tsx`

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { useReactTable, getCoreRowModel, ColumnDef, flexRender } from '@tanstack/react-table'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Checkbox } from '@/components/ui/checkbox'
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table'
import { Content } from '@/lib/admin/types'
import { format } from 'date-fns'
import { ko } from 'date-fns/locale'
import { Eye, Trash2 } from 'lucide-react'
import { Pagination } from '@/components/explorer/Pagination'
import Image from 'next/image'

interface ContentTableClientProps {
  contents: Content[]
  totalCount: number
  currentPage: number
  pageSize: number
  loading: boolean
  onPageChange: (page: number) => void
  onBulkDelete: (contentIds: string[]) => void
}

export function ContentTableClient({
  contents,
  totalCount,
  currentPage,
  pageSize,
  loading,
  onPageChange,
  onBulkDelete,
}: ContentTableClientProps) {
  const router = useRouter()
  const [rowSelection, setRowSelection] = useState({})

  const totalPages = Math.ceil(totalCount / pageSize)

  const getStatusBadge = (isAnalyzed: boolean | null) => {
    if (isAnalyzed === true) {
      return (
        <Badge className="truncate bg-green-100 text-green-700 hover:bg-green-100">
          완료
        </Badge>
      )
    } else if (isAnalyzed === null) {
      return (
        <Badge className="truncate bg-yellow-100 text-yellow-700 hover:bg-yellow-100">
          대기
        </Badge>
      )
    } else {
      return (
        <Badge className="truncate bg-blue-100 text-blue-700 hover:bg-blue-100">
          분석 중
        </Badge>
      )
    }
  }

  const columns: ColumnDef<Content>[] = [
    {
      id: 'select',
      header: ({ table }) => (
        <Checkbox
          checked={table.getIsAllPageRowsSelected()}
          onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
        />
      ),
      cell: ({ row }) => (
        <Checkbox
          checked={row.getIsSelected()}
          onCheckedChange={(value) => row.toggleSelected(!!value)}
          aria-label="Select row"
        />
      ),
      enableSorting: false,
      enableHiding: false,
    },
    {
      id: 'thumbnail',
      header: '썸네일',
      cell: ({ row }) => (
        <div className="relative h-12 w-12 overflow-hidden rounded border">
          <Image
            src={row.original.file_path}
            alt={row.original.file_name}
            fill
            className="object-cover"
          />
        </div>
      ),
    },
    {
      accessorKey: 'file_name',
      header: '파일명',
      cell: ({ row }) => <div className="truncate font-medium max-w-[200px]">{row.getValue('file_name')}</div>,
    },
    {
      accessorKey: 'user_name',
      header: '업로더',
      cell: ({ row }) => <div className="truncate text-gray-600">{row.getValue('user_name') || '-'}</div>,
    },
    {
      accessorKey: 'collection_name',
      header: '컬렉션',
      cell: ({ row }) => <div className="truncate text-gray-600">{row.getValue('collection_name') || '미분류'}</div>,
    },
    {
      accessorKey: 'is_analyzed',
      header: '분석 상태',
      cell: ({ row }) => getStatusBadge(row.getValue('is_analyzed')),
    },
    {
      accessorKey: 'detected_count',
      header: '발견 건수',
      cell: ({ row }) => {
        const count = row.getValue('detected_count') as number
        return count > 0 ? (
          <Badge variant="destructive" className="bg-red-100 text-red-700 hover:bg-red-100">
            {count}건
          </Badge>
        ) : (
          <span className="text-gray-400">-</span>
        )
      },
    },
    {
      accessorKey: 'created_at',
      header: '업로드일',
      cell: ({ row }) => (
        <div className="truncate text-gray-600">
          {format(new Date(row.getValue('created_at')), 'PPP', { locale: ko })}
        </div>
      ),
    },
    {
      id: 'actions',
      header: () => <div className="text-right">작업</div>,
      cell: ({ row }) => (
        <div className="text-right">
          <Button
            variant="ghost"
            size="sm"
            onClick={() => router.push(`/admin/contents/${row.original.id}`)}
            className="gap-1"
          >
            <Eye className="h-4 w-4" />
            상세
          </Button>
        </div>
      ),
    },
  ]

  const table = useReactTable({
    data: contents,
    columns,
    getCoreRowModel: getCoreRowModel(),
    manualPagination: true,
    pageCount: totalPages,
    state: {
      rowSelection,
      pagination: {
        pageIndex: currentPage - 1,
        pageSize,
      },
    },
    onRowSelectionChange: setRowSelection,
  })

  const selectedIds = table.getFilteredSelectedRowModel().rows.map((row) => row.original.id)

  return (
    <div className="space-y-4">
      {/* 일괄 작업 버튼 (항상 렌더링, AI 분석 제거) */}
      <div className="flex items-center justify-end gap-2">
        {selectedIds.length > 0 && (
          <span className="text-sm text-gray-500">{selectedIds.length} 선택됨</span>
        )}
        <Button
          size="sm"
          variant="outline"
          disabled={selectedIds.length === 0}
          onClick={() => {
            onBulkDelete(selectedIds)
            setRowSelection({})
          }}
          className="gap-1 text-red-600 hover:text-red-700"
        >
          <Trash2 className="h-4 w-4" />
          일괄 삭제
        </Button>
      </div>

      {/* 테이블 */}
      <div className="overflow-x-auto rounded-lg border bg-white">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(header.column.columnDef.header, header.getContext())}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          {loading ? (
            <TableBody>
              {Array.from({ length: pageSize }).map((_, index) => (
                <TableRow key={`skeleton-${index}`}>
                  <TableCell colSpan={columns.length}>
                    <div className="h-10 animate-pulse rounded bg-gray-100" />
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          ) : (
            <TableBody>
              {table.getRowModel().rows?.length ? (
                table.getRowModel().rows.map((row) => (
                  <TableRow
                    key={row.id}
                    data-state={row.getIsSelected() && 'selected'}
                    className="hover:bg-gray-50"
                  >
                    {row.getVisibleCells().map((cell) => (
                      <TableCell key={cell.id}>
                        {flexRender(cell.column.columnDef.cell, cell.getContext())}
                      </TableCell>
                    ))}
                  </TableRow>
                ))
              ) : (
                <TableRow>
                  <TableCell colSpan={columns.length} className="h-24 text-center text-gray-500">
                    검색 결과가 없습니다.
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          )}
        </Table>
      </div>

      {/* 페이지네이션 */}
      <div className="flex items-center justify-between">
        <div className="text-sm text-gray-600">
          전체 {totalCount}개 중 {contents.length}개 표시
        </div>
        <Pagination
          currentPage={currentPage}
          totalPages={totalPages}
          onPageChange={onPageChange}
          disabled={loading}
        />
      </div>
    </div>
  )
}
```

**주요 변경사항:**
- TanStack Table 사용 (Zustand 제거)
- `rowSelection` 로컬 상태로 관리
- AI 분석 관련 컬럼/버튼 제거
- 일괄 삭제만 유지
- 로딩 스켈레톤 추가
- 페이지네이션 컴포넌트 통합

### 5.3 페이지 컴포넌트 개선

**파일**: `app/admin/contents/page.tsx`

```typescript
'use client'

import { useState, useEffect } from 'react'
import { useAdminTitle } from '@/components/admin/layout/AdminContext'
import { ContentFilters } from '@/components/admin/contents/ContentFilters'
import { ContentTableClient } from '@/components/admin/contents/ContentTableClient'
import { useToast } from '@/hooks/use-toast'
import { Content, ContentFilters as ContentFiltersType } from '@/lib/admin/types'
import {
  getContentsWithPagination,
  bulkDeleteContents,
} from '@/lib/api/contents'

export default function AdminContentsPage() {
  useAdminTitle('콘텐츠 관리')
  const { toast } = useToast()

  const [contents, setContents] = useState<Content[]>([])
  const [totalCount, setTotalCount] = useState(0)
  const [loading, setLoading] = useState(true)
  const [filters, setFilters] = useState<ContentFiltersType>({
    page: 1,
    search: undefined,
    is_analyzed: undefined,
  })

  // 데이터 페칭
  useEffect(() => {
    async function fetchData() {
      setLoading(true)
      try {
        const result = await getContentsWithPagination({
          page: filters.page,
          pageSize: 10,
          search: filters.search,
          is_analyzed: filters.is_analyzed,
        })

        if (result.success && result.data) {
          setContents(result.data)
          setTotalCount(result.totalCount)
        } else {
          toast({
            title: '오류',
            description: result.error || '콘텐츠 목록을 불러오는데 실패했습니다.',
            variant: 'destructive',
          })
        }
      } catch (error) {
        toast({
          title: '오류',
          description: '콘텐츠 목록을 불러오는데 실패했습니다.',
          variant: 'destructive',
        })
      } finally {
        setLoading(false)
      }
    }
    fetchData()
  }, [filters, toast])

  const handlePageChange = (page: number) => {
    setFilters({ ...filters, page })
  }

  const handleBulkDelete = async (contentIds: string[]) => {
    if (!confirm(`${contentIds.length}개의 콘텐츠를 삭제하시겠습니까?`)) {
      return
    }

    try {
      const result = await bulkDeleteContents(contentIds)
      if (result.success) {
        toast({
          title: '삭제 완료',
          description: `${contentIds.length}개의 콘텐츠를 삭제했습니다.`,
        })
        // 데이터 새로고침
        setFilters({ ...filters })
      } else {
        toast({
          title: '오류',
          description: result.error || '일괄 삭제에 실패했습니다.',
          variant: 'destructive',
        })
      }
    } catch (error) {
      toast({
        title: '오류',
        description: '일괄 삭제에 실패했습니다.',
        variant: 'destructive',
      })
    }
  }

  return (
    <div className="space-y-6">
      {/* 필터 */}
      <ContentFilters filters={filters} onFilterChange={setFilters} />

      {/* 콘텐츠 테이블 */}
      <ContentTableClient
        contents={contents}
        totalCount={totalCount}
        currentPage={filters.page}
        pageSize={10}
        loading={loading}
        onPageChange={handlePageChange}
        onBulkDelete={handleBulkDelete}
      />
    </div>
  )
}
```

**주요 변경사항:**
- `useAdminStore` 제거 → 로컬 `useState` 사용
- Mock 데이터 제거 → `getContentsWithPagination` 사용
- `useMemo` 필터링 제거 → 서버 사이드 필터링
- 일괄 분석 핸들러 제거 → 일괄 삭제만 유지
- 로딩 상태 관리 추가
- Toast 알림 추가

### 5.4 타입 정의 업데이트

**파일**: `lib/admin/types.ts` (기존 파일 수정)

```typescript
export interface ContentFilters {
  page: number              // 추가
  user_id?: string
  is_analyzed?: boolean | null
  collection_id?: string
  search?: string
}
```

## 6. 제거할 컴포넌트 및 코드

### 6.1 제거할 컴포넌트

1. **AnalysisButton** (`components/admin/contents/AnalysisButton.tsx`)
   - 개별 콘텐츠 AI 분석 버튼
   - 더 이상 사용하지 않음

2. **AnalysisStatusBadge** 사용 위치 변경
   - 현재: 별도 컴포넌트
   - 변경: `ContentTableClient` 내부에 인라인으로 이동 (회원 관리 페이지와 일관성)

### 6.2 Zustand Store 정리

**파일**: `lib/admin/store.ts`

```typescript
// ❌ 제거할 상태
selectedContentIds: string[]
toggleContentSelection: (id: string) => void
clearSelections: () => void

// ✅ 유지할 상태
contentFilters: ContentFilters
setContentFilters: (filters: Partial<ContentFilters>) => void
```

**변경 후:**
```typescript
interface AdminStore {
  // User filters
  userFilters: UserFilters
  setUserFilters: (filters: Partial<UserFilters>) => void

  // Content filters (선택 상태 제거)
  contentFilters: ContentFilters
  setContentFilters: (filters: Partial<ContentFilters>) => void

  // ❌ 선택 관련 상태 완전 제거
  // selectedContentIds, toggleContentSelection, clearSelections
}
```

## 7. 구현 단계

### Phase 1: API 레이어 구현
1. `lib/api/contents.ts`에 `getContentsWithPagination` 함수 추가
2. `lib/api/contents.ts`에 `bulkDeleteContents` 함수 추가
3. 테스트 (Supabase 쿼리 동작 확인)

### Phase 2: 컴포넌트 리팩토링
1. `ContentFilters.tsx` 수정
   - 검색 placeholder 변경
   - page 상태 추가
2. `ContentTableClient.tsx` 신규 작성
   - TanStack Table 설정
   - AI 분석 버튼 제거
   - 일괄 삭제만 유지
3. `app/admin/contents/page.tsx` 수정
   - useEffect 데이터 페칭
   - 로컬 상태 관리

### Phase 3: 정리 및 최적화
1. `AnalysisButton.tsx` 컴포넌트 삭제
2. Zustand Store 정리 (선택 상태 제거)
3. Mock 데이터 제거 (`lib/admin/mock-data.ts`)
4. 타입 정의 업데이트

### Phase 4: 테스트 및 검증
1. 검색 기능 테스트 (파일명, 업로더명, 컬렉션명)
2. 필터링 테스트 (분석 상태)
3. 페이지네이션 테스트
4. 일괄 삭제 기능 테스트
5. UI 일관성 검증 (회원 관리 페이지와 비교)

## 8. 테스트 시나리오

### 8.1 데이터 조회 테스트

```typescript
// 시나리오 1: 기본 조회 (페이지 1, 전체 상태)
const result = await getContentsWithPagination({ page: 1, pageSize: 10 })
// 기대: 최신 콘텐츠 10개, user_name, collection_name, detected_count 포함

// 시나리오 2: 분석 상태 필터링
const result = await getContentsWithPagination({
  page: 1,
  pageSize: 10,
  is_analyzed: null // 대기만
})
// 기대: is_analyzed가 null인 콘텐츠만 반환

// 시나리오 3: 검색 (파일명)
const result = await getContentsWithPagination({
  page: 1,
  pageSize: 10,
  search: 'test.jpg'
})
// 기대: 파일명에 'test.jpg' 포함된 콘텐츠

// 시나리오 4: 검색 (업로더명)
const result = await getContentsWithPagination({
  page: 1,
  pageSize: 10,
  search: '홍길동'
})
// 기대: 업로더명에 '홍길동' 포함된 콘텐츠

// 시나리오 5: 검색 (컬렉션명)
const result = await getContentsWithPagination({
  page: 1,
  pageSize: 10,
  search: '2024년 프로젝트'
})
// 기대: 컬렉션명에 '2024년 프로젝트' 포함된 콘텐츠
```

### 8.2 일괄 삭제 테스트

```typescript
// 시나리오 1: 단일 콘텐츠 삭제
const result = await bulkDeleteContents(['content-uuid-1'])
// 기대: Storage 파일 삭제 + DB 레코드 삭제

// 시나리오 2: 다중 콘텐츠 삭제
const result = await bulkDeleteContents(['uuid-1', 'uuid-2', 'uuid-3'])
// 기대: 3개 파일 삭제, CASCADE로 detected_contents도 자동 삭제
```

### 8.3 UI/UX 테스트

1. **로딩 상태**: 데이터 로딩 중 스켈레톤 표시 확인
2. **선택 기능**: 체크박스 선택/해제 동작 확인
3. **일괄 작업**: 버튼 disabled 상태 확인
4. **페이지네이션**: 페이지 이동 시 데이터 갱신 확인
5. **검색**: 실시간 검색 동작 확인
6. **필터**: 분석 상태 필터 동작 확인

## 9. 성능 고려사항

### 9.1 현재 구현의 성능 특성

**N+1 쿼리 문제:**
```typescript
// 페이지당 10개 콘텐츠 × (1 + 10) = 11개 쿼리
// 1: contents + users + collections 조회
// 10: 각 content의 detected_count 조회
```

**예상 성능:**
- 페이지당 11개 쿼리
- Supabase는 HTTP 기반으로 지연시간 존재
- 하지만 페이지당 10개만 조회하므로 실용적

### 9.2 최적화 방안 (추후)

1. **PostgreSQL Function 사용**
   - 단일 쿼리로 모든 데이터 조회
   - JOIN + COUNT를 DB 레벨에서 처리

2. **Caching**
   - React Query 도입 (캐싱, 낙관적 업데이트)
   - Supabase Realtime 고려 (실시간 업데이트)

3. **인덱스 최적화**
   - `file_name`, `users.name`, `collections.name`에 GIN 인덱스 추가
   - ILIKE 검색 성능 향상

## 10. 구현 체크리스트

### API 레이어
- [ ] `getContentsWithPagination` 함수 구현
- [ ] `bulkDeleteContents` 함수 구현
- [ ] Supabase 쿼리 테스트

### 컴포넌트
- [ ] `ContentFilters.tsx` 수정 (검색 placeholder, page 상태)
- [ ] `ContentTableClient.tsx` 신규 작성
- [ ] `app/admin/contents/page.tsx` 수정
- [ ] `AnalysisButton.tsx` 삭제
- [ ] `lib/admin/types.ts` 타입 업데이트

### 상태 관리
- [ ] Zustand Store 정리 (선택 상태 제거)
- [ ] Mock 데이터 제거

### 테스트
- [ ] 기본 조회 동작 확인
- [ ] 검색 기능 테스트 (파일명, 업로더명, 컬렉션명)
- [ ] 필터링 테스트 (분석 상태)
- [ ] 페이지네이션 테스트
- [ ] 일괄 삭제 테스트
- [ ] UI 일관성 검증

### 문서화
- [ ] 변경사항 CHANGELOG 작성
- [ ] API 문서 업데이트

## 11. 예상 결과

### 11.1 Before (현재)
- Mock 데이터 사용
- 클라이언트 사이드 필터링
- Zustand 전역 상태
- AI 분석 버튼 존재
- 파일명만 검색 가능
- 페이지네이션 없음

### 11.2 After (개선 후)
- 실제 Supabase 데이터
- 서버 사이드 필터링
- TanStack Table 로컬 상태
- AI 분석 버튼 제거
- 파일명 + 업로더명 + 컬렉션명 검색
- 페이지네이션 지원

### 11.3 일관성 달성
- 회원 관리와 동일한 디자인 시스템
- 동일한 데이터 조회 패턴
- 동일한 상태 관리 방식
- 동일한 UI/UX 경험

## 12. 참고 자료

- [회원 관리 페이지 구현](./020_회원_관리_페이지_실제_데이터_연동_및_페이지네이션.md)
- [DATABASE_SCHEMA.md](../DATABASE_SCHEMA.md)
- [TanStack Table 문서](https://tanstack.com/table/v8)
- [Supabase Query 가이드](https://supabase.com/docs/reference/javascript/select)
